import nltk
import types
import json
import sys
#globalvariable,result contains all data that a goal needs
#globalvariable,we use coordinate to discribe the world and use d_world to
#represent it 
result={}
d_world=[]
world=[]
world_objects=[]

#reverse process of digitalize_the_world
#from coordinate to object
#like: from (1,1) to red large ball
#used for ambiguity
def realize_the_world(coordinates,world,objects):
      if(not isinstance(coordinates,list)):
            coord=[]
            coord.append(coordinates)
            coordinates=list(coord)
      map_to_real_world=[]
      if(coordinates==d_world[-1]):
            map_to_real_world.append("the floor")
            return map_to_real_world
      for coord in coordinates:
            co=coord.split(",")
            if(co[1]=="-1"):
                  co[1]="1"
            obj=world[int(co[0])-1][int(co[1])-1]
            discript=objects.get(obj)
            signature=discript.get("size","")
            signature=signature+" "+discript.get("color","")
            signature=signature+" "+discript.get("form","")
            signature=signature.split(" ")  
            map_to_real_world=len(map_to_real_world)==0 and signature or intersect(map_to_real_world,signature)  
      
      for obj in objects:
            duscript=objects.get(obj) 
            if(map_to_real_world.count(discript.get("form"))!=0):
                  return map_to_real_world
      map_to_real_world.append("object")
      return map_to_real_world
#relatioon: on,inside,beside etc.
#relative_coordinate: the coordinate of object after on,inside or beside etc.
def deal_with_relation(relation,relative_coordinate):
      index=0
      coord=list(relative_coordinate)
      if(relation.startswith("on") or relation.startswith("above") or relation.startswith("in")):
             
            for i in coord:
                  co=i.split(",")
                  co[1]=str(int(co[1])+1)
                  coord[index]=(co[0]+","+co[1])
                  index+=1
                 
            return coord
      elif(relation.startswith("under")):
            for i in coord:
                  co=i.split(",")
                  co[1]=str(int(co[1])-1)
                  coord[index]=(co[0]+","+co[1])
                  index+=1
            return coord
      #negative 1 denote that we ignore the value of this dimension
      elif(relation.find("left")>=0):
            for i in coord:
                  co=i.split(",")
                  co[0]=str(int(co[0])-1)
                  coord[index]=(co[0]+",-1")
                  index+=1
            return coord
      elif(relation.find("right")>=0):
            for i in coord:
                  co=i.split(",")
                  co[0]=str(int(co[0])+1)
                  coord[index]=(co[0]+",-1")
                  index+=1
            return coord
      elif(relation.startswith("beside")):
            be_coord=[]
            for i in coord:
                  co=i.split(",")
                  be_coord.append(str(int(co[0])-1)+",-1")
                  be_coord.append(str(int(co[0])+1)+",-1")
                  index+=1
            return be_coord
#return the intersection of two coordinate array.
#Like arr1=[(1,2),(2,3)],arr2=[(1,2),(2,4)],we get(1,2)
def intersect(arr1,arr2):
      intersection=[];
      if(len(arr1)==0 or len(arr2)==0):
            return len(arr1)==0 and arr1 or arr2
      for i in arr1:
            for j in arr2:
                  if(i==j):
                        intersection.append(i)
                  if(i.find("-1")>0 or j.find("-1")>0):
                        if(i.split(",")[0]==j.split(",")[0]):
                              intersection.append(i.find("-1")>0 and j or i)
                              break
      return intersection
#from the signature of the object we could get its or their coordinate
#Like the green ball or the large box, (quantifier,size,color,form) is signature
def signature2position(signature):
      coordinate=[]
      if(signature=="floor"):
            coordinate=list(d_world[-1])
            return coordinate
      sig=signature.split(" ")
      quantifier=sig[0]
      
      form=sig[-1]
      #since when quantifier is all the word of object is plural like all boxes,then d_world[2].get("boxes") will return null
      #so that we just for all keys in d_world[2] we check whether they are similar like boxes.contain(box)
      if(quantifier=="all"):
            for f in d_world[2].keys():
                  if(form.find(f)>=0):
                        coordinate=d_world[2].get(f)
      else:
            coordinate=d_world[2].get(form)
      for i in sig[1:-1]:
            s=d_world[0].get(i,"")
            c=d_world[1].get(i,"") 
            coordinate=intersect((s=="" and c or s),coordinate)
      return coordinate
#we use coordinate to discribe the world
def digitalize_the_world(world,objects):
      col=0
      digital_world=[{},{},{},[]]
      #first dictionary contains  the coordinate of specific size
      digital_world[0]={}
      #second dictionary contains  the coordinate of specific color
      digital_world[1]={}
      #third dictionary contains the coordinate of specific form 
      digital_world[2]={}
      #last dictionary contains the coordinate of the floor.we assume they are (i,0)
      digital_world[3]=[]
      for w in world:
          row=0
          col=col+1
          digital_world[3].append(str(col)+","+"0")
          for j in w:
              row=row+1
              for object in objects:
                  o=objects[object]
                  if(object==j):
                      tempt=digital_world[0].get(o["size"],[ ])
                      tempt.append((str(col)+","+str(row)))
                      digital_world[0][o["size"]]=tempt

                      tempt=digital_world[1].get(o["color"],[ ])
                      tempt.append((str(col)+","+str(row))) 
                      digital_world[1][o["color"]]=tempt

                      tempt=digital_world[2].get(o["form"],[ ])
                      tempt.append((str(col)+","+str(row)))
                      digital_world[2][o["form"]]=tempt
      
      return digital_world

#get the coordinate of location like location:on the green box.
#we will return(coordinate(green box).x,coordnate(green box).y+1)
def deal_with_location(location):
     location_relation=location[0]
     location_entity=location[1]
     entity_position=deal_with_entity(location_entity)
      
     return deal_with_relation(location_relation.node["sem"],entity_position)

def deal_with_entity(entity):
     category_entity=len(entity)
      
     if(category_entity==1):
           ent_position=signature2position(entity.node["sem"])
           #if the coordinate is null then we could just exit and notify users that object does not exist
           if(len(ent_position)==0):
                 print entity.node["sem"]+" does not exist in the world"
                 sys.exit(0)

           return  ent_position
     elif(category_entity==2):
           quantifier=entity[0].node["sem"]
           object=""

           for i in entity[1]:
                object=object+" "+i[0]
           
           signature=quantifier+object

           ent_position=signature2position(signature)

           if(len(ent_position)==0):
                 print signature+" does not exist in  the world"
                 sys.exit(0)

           return ent_position
      
     elif(category_entity==4):
           quantifier=entity[0].node["sem"]
           object=""

           for i in entity[1]:
                object=object+" "+i[0]
           signature=quantifier+object

           basic_object_position=signature2position(signature)
        
           if(len(basic_object_position)==0):
                 print  signature+" does not exist in the world"
                 sys.exit(0)

                
           location=entity[3]
          
           rel_position=deal_with_location(location)
            
           compound_object=intersect(basic_object_position,rel_position)
           #check whether the relation exist between to object
           #like the green box on the red table.But there are no green box on the red table.
           if(len(compound_object)==0):
                 print "relation  between "+str(basic_object_position) +" and "+str(rel_position)+" does not exist"
                 sys.exit(0)
             
           return compound_object
def put(put_command):
     location=put_command[2]
     position_of_target=deal_with_location(location)
     result["original_position"]="it"
     result["target_position"]=position_of_target
     #used to deal with ambiguity
     result["proposition"]=location[0].node["sem"]
     result["quantifier"]=entity[0].node["sem"]
def move(move_command):
     entity=move_command[1]
      
     position_of_entity=deal_with_entity(entity)

      
     location=move_command[2]

     position_of_target=deal_with_location(location)

     result["original_position"]=position_of_entity
     result["target_position"]=position_of_target
     #used to deal with ambiguity
     result["proposition"]=location[0].node["sem"]
     result["quantifier"]=entity[0].node["sem"]
def take(take_command):
      entity=take_command[1]
      position_of_entity=deal_with_entity(entity) 
      result["original_position"]=position_of_entity
      result["quantifier"]=entity[0].node["sem"]
#the result contains  original position of the object and the position that i want to be moved to
#So we could check the whether this is possible and how to do this according to this two positions      
def interpret(tree):
    result.clear()
    opt_will_you=tree[0]
    opt_please=tree[1]
    basic_command=tree[2]
    action=basic_command.node["sem"][0]
    result["action"]=action
    if(action=="take"):
        take(tree[2])
    elif(action=="put"):
        put(tree[2])
    elif(action=="move"):
        move(tree[2])
    else:
        print "error"
    
         
    return dict(result)
#there three kind of ambiguities:
#1: there are more than one parse tree for one sentence
#2: there are more than one object in the world
#3: there are more than one destination for the object
def deal_with_ambiguity(goals):
      if(len(goals)>1):
            question=[]
            for g in goals:
                  response=[]
                  action=g.get("action")
                  propo=g.get("proposition")
        
                  base_p=g.get("original_position")
                  target_p=g.get("target_position")
                  if(propo.startswith("on") or propo.startswith("above") or propo.startswith("in")):
                        target_p=deal_with_relation("under",target_p)
                  elif(propo=="under"):
                        target_p=deal_with_relation("on",target_p)
                  elif(propo.find("left")>=0):
                        target_p=deal_with_relation("right",target_p)
                  elif(propo.find("right")>=0):
                        target_p=deal_with_relation("left",target_p)
                  response.append(action)
                  response.append(" ".join(realize_the_world(base_p,world,world_objects)))
                  
                  if(propo.find("beside")>=0):
                        columns=[ i.split(",")[0] for i in target_p]
                        response.append("on")
                        response.append("column"+" or column".join(columns))      
                  else:
                        response.append(propo)
                        response.append(" ".join(realize_the_world(target_p,world,world_objects)))
                  question.append(" ".join(response))
            
            print " or ".join(question)
      else:
           response=[]
           goal=goals.pop()
           propo=goal.get("proposition")
           quantifier=goal.get("quantifier","")
           if(quantifier!="every" and quantifier!="all" and quantifier!="any" and len(goal.get("original_position"))>1):
                 for i in goal.get("original_position"):
                      response.append(" ".join(realize_the_world(i,world,world_objects)))
                 print " or ".join(response)
           response=[]     
           target_p=goal.get("target_position","")
           if(len(target_p)>1 and deal_with_relation("under",target_p)!=d_world[-1]):
                 if(propo.startswith("on") or propo.startswith("above") or propo.startswith("in")):
                        target_p=deal_with_relation("under",target_p)
                 elif(propo=="under"):
                              target_p=deal_with_relation("on",target_p)
                 elif(propo.find("left")>=0):
                        target_p=deal_with_relation("right",target_p)
                 elif(propo.find("right")>=0):
                        target_p=deal_with_relation("left",target_p)
                 
                 if(propo.find("beside")>=0):
                       columns=[ i.split(",")[0] for i in target_p]
                       response.append("column"+" or column".join(columns))
                 else:
                       for t in target_p:
                             response.append(" ".join(realize_the_world(t,world,world_objects)))
                 print " or ".join(response)                
def move_away(array_object):
     print ""
def solve(goal):
     position=goal.get("original_position")[0].split(",")
     if(len(world[int(position[0])-1])==int(position[1])-1):
            print "it is ok,just put it on that position"
     else:
            upper_objects=[]
            for i in range(int(position[1]),len(world[int(position[0])-1])+1):
                  upper_objects.append(position[0])+","+str(i))  
            print upper_objects              
def main():          
     grammar=nltk.data.load("file:shrdlite_grammar.fcfg",cache=False) 
     parser=nltk.FeatureChartParser(grammar)
     sentence="take the yellow box "
     sentence=sentence.split()
     #content of function parse
     do_parse = getattr(parser, 'nbest_parse', 
                       getattr(parser, 'parse_all', parser.parse))
     trees=do_parse(sentence)
     #content of function parse
     goals=[interpret(tree) for tree in trees]
     #deal with ambuiguity
     deal_with_ambiguity(list(goals))
     #test for how to solve the goal
     #note:this part should be written in another file
     goal=goals.pop()
     solve(goal)
if __name__=="__main__":
      f=file("medium.json")
      json_data=json.load(f)
      world_objects=json_data["objects"]
      world=json_data["world"]
      d_world=digitalize_the_world(world,world_objects)
      main()
